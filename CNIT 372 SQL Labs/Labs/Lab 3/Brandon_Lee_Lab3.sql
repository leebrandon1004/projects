--Question 1
begin
    DBMS_OUTPUT.PUT_LINE ('Hello world');
end;
/

--Question 2
SET SERVEROUTPUT ON;
/

--Question 3
begin
    DBMS_OUTPUT.PUT_LINE ('Hello world');
end;
/

--Question 4

/

--Question 5
begin 
DBMS_OUTPUT.PUT_LINE ('The Ubiquitous Hello World');
end;
/

--Question 6
begin
    DBMS_OUTPUT.PUT('The');
    DBMS_OUTPUT.PUT(' ');
    DBMS_OUTPUT.PUT('Ubiquitous');
    DBMS_OUTPUT.PUT(' ');
    DBMS_OUTPUT.PUT('Hello');
    DBMS_OUTPUT.PUT(' ');
    DBMS_OUTPUT.PUT_LINE('World');
end;
/

--Question 7

/

--Question 8

/

--Question 9

/

--Question 10

/

--Question 11
begin
    DBMS_OUTPUT.PUT_LINE('My name is ' || '&sv_YourName');
end;
/

--Question 12
SET VERIFY ON;
/

--Question 13
begin
    DBMS_OUTPUT.PUT_LINE('My name is ' || '&sv_YourName');
end;
/

--Question 14
SET VERIFY OFF;
/

--Question 15

/

--Question 16

/

--Question 17
begin
    DBMS_OUTPUT.PUT_LINE('My name is ' || '&sv_YourName');
end;
/

--Question 18
begin
    DBMS_OUTPUT.PUT_LINE('Today is ' || '&sv_day');
    DBMS_OUTPUT.PUT_LINE('Tomorrow is ' || '&sv_day');
end;

/

--Question 19
begin
    DBMS_OUTPUT.PUT_LINE('Today is ' || '&&sv_day');
    DBMS_OUTPUT.PUT_LINE('Tomorrow is ' || '&sv_day');
end;
/

--Question 20

/

--Question 21
declare
    V_DAY varchar2(10) := '&sv_day1';
begin
    DBMS_OUTPUT.PUT_LINE ('Today is ' || V_DAY);
end;

/

--Question 22
declare
    V_DAY varchar2(10);
begin
    V_DAY := to_char (sysdate, 'Day');
    DBMS_OUTPUT.PUT_LINE ('Today is ' || V_DAY);
    DBMS_OUTPUT.PUT_LINE ('Tomorrow is ' || to_char (sysdate +1, 'Day'));
end;
/


--Question 23
select employeeID
from employee
where employeeid = '100001';
/

--Question 24
declare 
    V_EMPLOYEEID EMPLOYEE.EMPLOYEEID%TYPE;
    V_LASTNAME EMPLOYEE.LASTNAME%TYPE;
    V_FIRSTNAME EMPLOYEE.FIRSTNAME%TYPE;
    
begin
    select  EMPLOYEEID, LASTNAME, FIRSTNAME
        into    V_EMPLOYEEID, V_LASTNAME, V_FIRSTNAME
    from EMPLOYEE
    where EMPLOYEEID = '100001';
    
    DBMS_OUTPUT.PUT_LINE('Employee ID   LASTNAME    FIRSTNAME');
    DBMS_OUTPUT.PUT_LINE('====================================');
    DBMS_OUTPUT.PUT(V_EMPLOYEEID);
    DBMS_OUTPUT.PUT('              ');
    DBMS_OUTPUT.PUT('V_LASTNAME');
    DBMS_OUTPUT.PUT('          ');
    DBMS_OUTPUT.PUT_LINE(V_FIRSTNAME);
end;
/

--Question 25
select employeeID
from employee;
/

--Question 26
declare 
    V_EMPLOYEEID EMPLOYEE.EMPLOYEEID%TYPE;
    V_LASTNAME EMPLOYEE.LASTNAME%TYPE;
    V_FIRSTNAME EMPLOYEE.FIRSTNAME%TYPE;
    
begin
    select  EMPLOYEEID, LASTNAME, FIRSTNAME
        into    V_EMPLOYEEID, V_LASTNAME, V_FIRSTNAME
    from EMPLOYEE;
    
    DBMS_OUTPUT.PUT_LINE('Employee ID   LASTNAME    FIRSTNAME');
    DBMS_OUTPUT.PUT_LINE('====================================');
    DBMS_OUTPUT.PUT(V_EMPLOYEEID);
    DBMS_OUTPUT.PUT('              ');
    DBMS_OUTPUT.PUT('V_LASTNAME');
    DBMS_OUTPUT.PUT('          ');
    DBMS_OUTPUT.PUT_LINE(V_FIRSTNAME);
end;
/

--Question 27

/

--Question 28

/

--Question 29
declare 
    V_EMPLOYEE employee%ROWTYPE;
    
begin
    select * INTO V_EMPLOYEE FROM EMPLOYEE WHERE EMPLOYEEID = '100001';
    DBMS_OUTPUT.PUT_LINE('Employee ID   LASTNAME    FIRSTNAME');
    DBMS_OUTPUT.PUT_LINE('====================================');
    DBMS_OUTPUT.PUT_LINE(V_EMPLOYEE.EMPLOYEEID ||'               '|| V_EMPLOYEE.LASTNAME||'           '||V_EMPLOYEE.FIRSTNAME);
end;
/

--Question 30
declare 
    V_AREACODE VARCHAR2(3) := '&v_AREACODE';
/

--Question 31a
declare 
    V_NUMBER_CUSTOMERS NUMBER;
    V_AREACODE VARCHAR2(3) := '&v_AREACODE';
BEGIN
SELECT COUNT(CUSTOMERID)
        INTO V_NUMBER_CUSTOMERS
    FROM CUSTOMER
    WHERE substr(Phone,1,3) = V_AREACODE;
END;
/

--Question 31b
declare 
    V_NUMBER_CUSTOMERS NUMBER;
    V_AREACODE VARCHAR2(3) := '&v_AREACODE';
BEGIN
SELECT COUNT(CUSTOMERID)
        INTO V_NUMBER_CUSTOMERS
    FROM CUSTOMER
    WHERE substr(Phone,1,3) = V_AREACODE;
END;
/

/* Results
--Question 1
Hello World

--Question 2
No output

--Question 3
No output before restarting and Hello World after restarting
The SQL Developer does not remember the SERVEROUTPUT perference. 

--Question 4
The SERVEROUTPUT setting controls whether SQL*Plus prints the output generated by the
DBMS_OUTPUT package from SQL procedures

Source: https://www.oreilly.com/library/view/oracle-sqlplus-the/0596007469/re85.html


--Question 5
The Ubiquitous Hello World


--Question 6
The Ubiquitous Hello World


--Question 7
I believe that the difference is that DBMS_OUTPUT. PUT procedure outputs results in
chronological order but it has to be followed by DBMS_OUTPUT.PUT_LINE procedure in
order to successfully output the result. However DBMS_OUTPUT.PUT_LINE can solely
stand by itself and successfully output the result.


--Question 8
The DBMS_OUTPUT.PUT is a single/partial package that is skipped by SQLPlus. It does
not output a result on screen without DBMS_OUTPUT.PUT_LINE which writes a full, but
empty line that outputs the results on screen.

Source: https://stackoverflow.com/questions/25722069/oracle-pl-sqls-dbms-output-put-line-vs-dbms-output-put


--Question 9
DBMS_OUTPUT.PUT_LINE is a package that allows to print the output to screen. This procedure
also trims off white space when not placed in the buffer.

Source: https://www.got-it.ai/solutions/sqlquerychat/sql-help/others/oracle-sql-developer-dbms_output-put_line-pl-sql/



--Question 10
The difference is that DBMS_OUTPUT.PUT is a single/partial package that does not output
the results on screen and skipped by SQLPlus but stores it in data. The DBMS_OUTPUT.PUT_LINE
writes a full but empty line which outputs the results on screen. Thus, DBMS_OUTPUT.PUT
itself cannot output the results on screen it has to have DBMS_OUTPUT.PUT_LINE after the 
DBMS_OUTPUT.PUT procedures.


--Question 11
A pop-up shows up after the command is ran and requests for a Name to the user.
I inputed my name for the pop-up:

My name is Brandon Lee

--Question 12
No Output


--Question 13

old:begin
    DBMS_OUTPUT.PUT_LINE('My name is ' || '&sv_YourName');
end;
new:begin
    DBMS_OUTPUT.PUT_LINE('My name is ' || 'Brandon Lee');
end;

My name is Brandon Lee

PL/SQL procedure successfully completed.


--Question 14
No Output

--Question 15
My name is Brandon Lee

PL/SQL procedure successfully completed.

--Question 16
The VERIFY attribute controls whether or not SQL*Plus displays before and after
images of each line that has a substitution variable.

Source: https://www.oreilly.com/library/view/oracle-sqlplus-the/0596007469/re106.html


--Question 17
I am prompted for the value twice when running the code wrice. This implies that if the
same value of sv_YourName is the same for all twice, the same value is outputted because 
there were no substitution made with the input.


--Question 18
Today is Tuesday
Tomorrow is Wednesday

Explanation: Yes, you can use the same variable name twice within the same unnamed block. The system
pop-ups up with the same block asking the: "sv_day" twice. However, the user has to 
remember the order of the same blocks in order to accurately process the output on screen.


--Question 19
Today is Tuesday
Tomorrow is Tuesday

PL/SQL procedure successfully completed.

Explanation: I was not prompted to provide the second ouput for sv_day. The difference of a addition
of another "%" in the first DBMS_OUTPUT at "sv_day" was the reason that caused this.


--Question 20
Today is Tuesday
Tomorrow is Tuesday

PL/SQL procedure successfully completed.

Explanation:I was not promted for any "sv_day". This implies that the previously 
inputted data in sv_day is persistant of its data by using the && command which means
that by using && the variable input is stored. 



--Question 21
Today is Tuesday

PL/SQL procedure successfully completed.


--Question 22
Today is Tuesday  
Tomorrow is Wednesday

PL/SQL procedure successfully completed.




--Question 23
One row is returned


--Question 24
Employee ID   LASTNAME    FIRSTNAME
====================================
100001              V_LASTNAME          Jim

PL/SQL procedure successfully completed.


--Question 25
40 rows are returned


--Question 26
Error starting at line : 162 in command -
declare 
    V_EMPLOYEEID EMPLOYEE.EMPLOYEEID%TYPE;
    V_LASTNAME EMPLOYEE.LASTNAME%TYPE;
    V_FIRSTNAME EMPLOYEE.FIRSTNAME%TYPE;

begin
    select  EMPLOYEEID, LASTNAME, FIRSTNAME
        into    V_EMPLOYEEID, V_LASTNAME, V_FIRSTNAME
    from EMPLOYEE;

    DBMS_OUTPUT.PUT_LINE('Employee ID   LASTNAME    FIRSTNAME');
    DBMS_OUTPUT.PUT_LINE('====================================');
    DBMS_OUTPUT.PUT(V_EMPLOYEEID);
    DBMS_OUTPUT.PUT('              ');
    DBMS_OUTPUT.PUT('V_LASTNAME');
    DBMS_OUTPUT.PUT('          ');
    DBMS_OUTPUT.PUT_LINE(V_FIRSTNAME);
end;
Error report -
ORA-01422: exact fetch returns more than requested number of rows
ORA-06512: at line 7
01422. 00000 -  "exact fetch returns more than requested number of rows"
*Cause:    The number specified in exact fetch is less than the rows returned.
*Action:   Rewrite the query or change number of rows requested


--Question 27
I am attempting to assign 40 rows to each of the variables in 10d. This creates an error
due to the overflow of the number of rows in each variable.



--Question 28
A scalar variable only can store a value with no internal components. Thus, it only can store one value at once.


--Question 29
Employee ID   LASTNAME    FIRSTNAME
====================================
100001               Manaugh           Jim


PL/SQL procedure successfully completed.

Explanation: In 10b, the Lastname is not specified at the data but just shown as V_LASTNAME. But in 10h, it is shown
as the actual name from the database. The difference comes from that at 10h the code selects from all of the data at 
table EMPLOYEE but at 10b it specifies the columns to select from which may lead to a result missing.

--Question 30
N/A


--Question 31a
N/A


--Question 31b
N/A

*/